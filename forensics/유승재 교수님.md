## **문제 이름**

유승재 교수님



## 문제 

유승재 교수님께서 열정적으로 강의하시는 모습을 사진에 담았다.

한 장만 찍으려고 했지만 너무 눈이 부셔서 모르고 두 장을 찍어버렸다..

어라...? 사진이 똑같아 보이지만 뭔가 미묘하게 다르다.

잘 나온 사진 한 장만 교수님께 드리려고 하는데 어떤 걸 드려야 하지..?

일단 두 사진이 어떻게 다른지 비교를 해야 겠다.

잠깐... 리눅스 명령어 중에 두 개의 파일을 비교하는 명령어와 옵션이 뭐였지?

비교해서 다른 부분을 찾아보면 플래그를 얻을 수 있을 것 같다. 

Flag Format : scpCTF{찾은 플래그}



## 문제 취지

똑같은 사진처럼 보여도 그 안에 들어있는 데이터 값을 다르게 할 수 있다.

하지만 데이터 값을 바꾸게 되면 사진의 모습이나 형태도 바뀌게 된다.

본 문제는 두 개의 사진 파일을 제시함으로써 두 개의 사진이 똑같아 보이지만, 그 안에 있는 소수의 데이터 값을 다르게 하여 안에 있는 문자열을 확인하고 플래그를 입력하는 문제이다.

원래 데이터 값을 바꾸고 사진을 확인해보면 그 사진은 깨지거나, 정상적인 형태가 색깔이 바뀔 수도 있고 아예 못 알아볼 정도로 사진이 변할 수도 있다.

출제자는 데이터 값을 변경하면서 사진의 형태나 모양이 바뀌지 않고, 원래의 모습을 유지할 수 있도록 데이터 값을 변경하였다.

원래의 모습과 똑같은 형태로 유지하기 위해서는 데이터를 잘 바꿔야 한다는게 특징이다.

문제에 접하는 학생들은 리눅스에서 cmp 명령어를 통하여 두 파일의 차이점을 확인할 수 있으며 차이점에 대한 다른 문자들을 출력할 수 있도록 문제를 만들었다.

또한 위에서 설명한 이 방법은 스테가노그래피로도 활용될 수 있으며 원본 사진과 모습은 같지만, 안에 있는 데이터를 조작하여 중요한 메시지를 숨길 수도 있다.

그리고 리눅스를 사용하면서 cmp 명령어는 거의 쓰이지 않고 있다.

그렇기 때문에 이 문제에 접하는 학생은 두 파일에 대한 차이점을 비교, 분석해주는 cmp 명령어와 그에 대한 옵션을 학습할 수 있으며, 앞으로 이와 비슷한 포렌식 문제에 접하게 되면 cmp 명령어를 잘 활용하여 문제를 쉽게 풀어 나갈 수 있을 것이다.

또한 두 가지의 다른 파일이 있지만 차이점을 알고 싶을 때도 어떤 차이점을 가지는지 알 수 있는 명령어가 바로 cmp 명령어이다.

## 풀이 방법

image1.jpg

![image](https://user-images.githubusercontent.com/40850499/68454062-d39f1b80-023a-11ea-8b32-66cad0c8894e.jpg)



image2.jpg

![image](https://user-images.githubusercontent.com/40850499/68454070-d69a0c00-023a-11ea-9959-ff5f167d58b5.jpg)

두 사진은 겉으로 보기에는 똑같은 사진처럼 보인다.

하지만 두 사진 안에 있는 헥스 값(데이터 값)은 다른 값을 가진다.



본 문제는 cmp 명령어를 활용하여 플래그를 얻는 문제이다.

cmp 명령어는 compare의 악쟈로서 두 개의 파일이 어떤 부분이 다른가를 비교해준다.

주어진 파일로 image1과 image2 이름으로 된 jpg 파일이 주어진다.

이 파일들을 리눅스로 옮겨서 경로를 확인 후, 터미널을 통해 cmp 명령어를 입력하면 다음과 같은 화면이 나오게 된다.

![image](https://user-images.githubusercontent.com/40850499/68454089-ea457280-023a-11ea-9f93-ea1c1ea9f11c.png)

**cmp 명령어 [1번째 파일] [2번째 파일]**

위와 같이 cmp 명령어와 파일 두 개를 입력해준다.

출력 화면은 위와 같이 나오게 되고, 아무 옵션 없이 cmp 명령어만 입력했다.

해석해보면 image1 파일과 image2 파일이 다른 점은 187 행의 19839 byte 부분이라는 것이다.

이렇게 아무 옵션 없이 사용할 경우 처음으로 다른 문자(데이터)의 위치만 알려주고, 나머지 다른 값을 알 수 없다.

좀 더 정확하게 알기 위해 옵션을 사용하여 cmp 명령어를 활용해보자.

![image](https://user-images.githubusercontent.com/40850499/68454114-00533300-023b-11ea-83b0-b2c7deedbf16.png)

위 화면은 cmp 명령어에 -l 옵션을 추가한 화면이다.

출력 값을 보면 19839 바이트 자리에서 서로 다른 문자(데이터 값)가 발견 되었고, image1의 19839 바이트 자리에 있는 문자는 아스키코드 8진수 121값인 Q를 나타낸다.

그리고 image2의 19839 바이트 자리에 있는 문자는 아스키코드 8진수 120값인 P를 나타낸다.

더 이해하기 쉽도록 HxD를 이용하여 분석해보면서 설명하겠다.

![image](https://user-images.githubusercontent.com/40850499/68454128-0cd78b80-023b-11ea-8f73-7d26883eceef.png)

이 화면은 HxD로 image1의 Q (리눅스에서 보이는 19839 바이트의 Q)를 나타낸 것이다.

왜 19839로 되어 있는데 HxD에는 19839가 안 보이나? 라고 의문이 들 수도 있다.

왼쪽 하단에 보이는 오프셋 값이 바로 19389를 나타낸다.

HxD는 16진수로 나타내기 때문에 리눅스에서 본 19839를 16진수로 나타낸 값이 바로 오프셋 값이다.

그리고 오프셋에는 4D7E라고 되어 있지만, 원래는 4D7F가 바이트 자리 값이 된다.

![image](https://user-images.githubusercontent.com/40850499/68454153-195be400-023b-11ea-8e92-283c6307751f.png)

그 이유는 맨 처음 오는 오프셋 값인 바로 0 때문이다.

0도 바이트 수에 포함되므로 바이트 자리를 계산할 때는 항상 1(오프셋 0)을 더해주어야 한다.

그리고 리눅스에서 본 121이 Q가 되는 이유는 아스키 코드 값을 8진수로 표현하였기 때문이다.

![image](https://user-images.githubusercontent.com/40850499/68454174-27aa0000-023b-11ea-9461-3d94cfa01236.png)

Q의 아스키 코드를 진수로 표현한 것이고, 왼쪽부터 10진수, 16진수, 8진수, 2진수로 표현하였다.

![image](https://user-images.githubusercontent.com/40850499/68454180-2d074a80-023b-11ea-9b2d-7dbdb9f0811e.png)

image2에서는 120으로 나온 것은 아스키 코드 P를 표현하기 위해서다.

**cmp명령어의 주요 옵션**

**-l** : 두 파일의 내용 중에서 다른 문자들에 대한 8진수 값 출력

**-s** : cmp의 결과 출력 x, 에러 코드를 반환 (같을 경우 = 0, 다를 경우 =1, 에러 발생 =2)

(위 에러코드는 화면상 출력 x, 시스템 내에서 반환 / -s 옵션은 화면에 출력되는 내용 없음)

**-i** : 바이트를 지정하여 파일내용 비교하기

**-H** : 큰 사이즈 파일 비교 시, 빠른 속도 비교

cmp 명령어의 많은 옵션들이 있지만, 이 문제에서 주로 쓰이는 옵션은 바로 -l이다.

이제 어떻게 분석하는지 알게 되었으니, image1과 image2를 차례로 분석해보자.

cmp -l로 분석한 바이트 자리 수와 아스키 코드(8진수)를 조합해보면 다음과 같은 문자열을 확인할 수 있다.



**image 1.jpg**

![image](https://user-images.githubusercontent.com/40850499/68454233-59bb6200-023b-11ea-94a5-330e514a522f.png)

![iamge](https://user-images.githubusercontent.com/40850499/68454254-663fba80-023b-11ea-9ec1-7c5aaf5cdb15.png)

리눅스 cmp -l로 image1.jpg를 분석한 텍스트(데이터)를 연결해보면 Q4sG4d6^B2@1s26gn이다.

정확히 무엇을 의미하는지 알 수 없다.

그래서 image2.jpg도 image1.jpg와 똑같이 분석해보자.



**image2.jpg**

![image](https://user-images.githubusercontent.com/40850499/68454296-85d6e300-023b-11ea-86d7-a5745fd46b71.png)

![image](https://user-images.githubusercontent.com/40850499/68454326-9c7d3a00-023b-11ea-893b-8bc5fe14f45e.png)



image1.jpg와 똑같이 문자열을 조합해보면 P3rF3c7_A190ri7hm이 나온다.

아까와는 상반대로 문자열을 언뜻 보면 PERFECT_ALGORITHM이라는 것처럼 보인다.

힌트로 알고리즘이랑 관련 되어 있다고 하였으니 이 문자열이 플래그가 된다.



## Flag

scpCTF{P3rF3c7_A190ri7hm}



## 힌트

리눅스에서 나오는 명령어의 결과 값은 10진수와 8진수를 사용합니다.

그리고 플래그를 자세히 확인해보면 알고리즘과 관련 되어 있습니다.
